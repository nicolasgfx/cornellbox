#pragma once

#include <vector>
#include <algorithm>
#include <cmath>
#include "../mesh/MeshData.h"

namespace Solver {

// Progressive refinement radiosity solver
inline void progressiveRefinement(PatchSoA& patches,
                                   const std::vector<std::vector<float>>& formFactors,
                                   uint32_t maxIterations = 100,
                                   float epsilon = 0.001f) {
    uint32_t N = static_cast<uint32_t>(patches.area.size());
    
    std::cout << "\n=== Progressive Refinement Solver ===\n";
    std::cout << "Patches: " << N << "\n";
    std::cout << "Max iterations: " << maxIterations << "\n";
    std::cout << "Convergence threshold: " << epsilon << "\n\n";
    
    // Enforce reflectance bounds to keep the solve stable
    uint32_t clampedBelow = 0;
    uint32_t clampedAbove = 0;
    for (uint32_t i = 0; i < N; ++i) {
        auto clampRho = [&](float& value) {
            if (value < 0.0f) {
                value = 0.0f;
                clampedBelow++;
            } else if (value > 1.0f) {
                value = 1.0f;
                clampedAbove++;
            }
        };

        clampRho(patches.rho_r[i]);
        clampRho(patches.rho_g[i]);
        clampRho(patches.rho_b[i]);
    }

    if (clampedBelow > 0 || clampedAbove > 0) {
        std::cout << "Adjusted reflectance values (" << clampedBelow
                  << " below 0, " << clampedAbove << " above 1).\n";
    }

    // Initialize: B = emit, Bu = emit
    for (uint32_t i = 0; i < N; ++i) {
        patches.B_r[i] = patches.emit_r[i];
        patches.B_g[i] = patches.emit_g[i];
        patches.B_b[i] = patches.emit_b[i];
        
        patches.Bu_r[i] = patches.emit_r[i];
        patches.Bu_g[i] = patches.emit_g[i];
        patches.Bu_b[i] = patches.emit_b[i];
    }
    
    // Debug: Count emissive patches
    uint32_t emissiveCount = 0;
    float totalEmission = 0.0f;
    for (uint32_t i = 0; i < N; ++i) {
        float emit = patches.emit_r[i] + patches.emit_g[i] + patches.emit_b[i];
        if (emit > 1e-6f) {
            emissiveCount++;
            totalEmission += emit;
        }
    }
    std::cout << "Emissive patches: " << emissiveCount << " (total emission: " << totalEmission << ")\n";
    std::cout << std::endl;
    
    // Progressive refinement iterations
    for (uint32_t iter = 0; iter < maxIterations; ++iter) {
        // Find patch with maximum unshot radiosity
        float maxBu = 0.0f;
        uint32_t maxPatch = 0;
        
        for (uint32_t i = 0; i < N; ++i) {
            float Bu_mag = std::abs(patches.Bu_r[i]) + 
                          std::abs(patches.Bu_g[i]) + 
                          std::abs(patches.Bu_b[i]);
            if (Bu_mag > maxBu) {
                maxBu = Bu_mag;
                maxPatch = i;
            }
        }
        
        // Check convergence
        if (maxBu < epsilon) {
            std::cout << "Converged after " << iter << " iterations\n";
            std::cout << "Final max unshot: " << maxBu << "\n";
            break;
        }
        
        if (iter % 10 == 0) {
            std::cout << "  Iteration " << iter << ": max unshot = " << maxBu 
                      << " (patch " << maxPatch << ")\n";
        }
        
        // Shoot radiosity from maxPatch to all other patches
        uint32_t p = maxPatch;
        float Bu_r_p = patches.Bu_r[p];
        float Bu_g_p = patches.Bu_g[p];
        float Bu_b_p = patches.Bu_b[p];
        
        // Debug: Count how many patches receive energy
        uint32_t recipientCount = 0;
        float totalEnergyShot = 0.0f;
        
        for (uint32_t j = 0; j < N; ++j) {
            if (j == p) continue;
            
            float F_pj = formFactors[p][j];
            if (F_pj < 1e-8f) continue;
            
            // Reflected radiosity: rho[j] * F[p,j] * Bu[p]
            float delta_r = patches.rho_r[j] * F_pj * Bu_r_p;
            float delta_g = patches.rho_g[j] * F_pj * Bu_g_p;
            float delta_b = patches.rho_b[j] * F_pj * Bu_b_p;
            
            // Safety check for NaN/Inf
            if (!std::isfinite(delta_r) || !std::isfinite(delta_g) || !std::isfinite(delta_b)) {
                if (iter == 0) {
                    std::cout << "      ERROR: Non-finite delta at j=" << j << " (F=" << F_pj 
                              << ", rho=" << patches.rho_r[j] << ")\n";
                }
                continue;
            }
            
            float delta_mag = delta_r + delta_g + delta_b;
            if (delta_mag > 1e-8f) {
                recipientCount++;
                totalEnergyShot += delta_mag;
            }
            
            // Update radiosity and unshot
            patches.B_r[j] += delta_r;
            patches.B_g[j] += delta_g;
            patches.B_b[j] += delta_b;
            
            patches.Bu_r[j] += delta_r;
            patches.Bu_g[j] += delta_g;
            patches.Bu_b[j] += delta_b;
        }
        
        // Debug logging every 10 iterations
        if (iter % 10 == 0) {
            std::cout << "    -> Shot energy to " << recipientCount << " patches (total: " << totalEnergyShot << ")\n";
        }
        
        // Critical debug for first iteration
        if (iter == 0) {
            std::cout << "\n  *** After iteration 0 (first bounce) ***\n";
            std::cout << "      Shooting patch: " << p << "\n";
            std::cout << "      Unshot radiosity: " << Bu_r_p << ", " << Bu_g_p << ", " << Bu_b_p << "\n";
            std::cout << "      Recipients: " << recipientCount << "/" << N << " patches\n";
            std::cout << "      Total energy distributed: " << totalEnergyShot << "\n";
            
            // Check how many patches now have non-zero radiosity
            uint32_t litPatches = 0;
            for (uint32_t i = 0; i < N; ++i) {
                float B = patches.B_r[i] + patches.B_g[i] + patches.B_b[i];
                if (B > 1e-6f) litPatches++;
            }
            std::cout << "      Patches with B > 0: " << litPatches << "/" << N << "\n";
            
            // Sample a few form factors from the light
            std::cout << "      Sample form factors from patch " << p << ":\n";
            for (uint32_t j = 0; j < std::min(5u, N); ++j) {
                if (j != p) {
                    std::cout << "        F[" << p << "," << j << "] = " << formFactors[p][j] << "\n";
                }
            }
            std::cout << std::endl;
        }
        
        // Clear unshot for the shooting patch
        patches.Bu_r[p] = 0.0f;
        patches.Bu_g[p] = 0.0f;
        patches.Bu_b[p] = 0.0f;
    }
    
    std::cout << "\n=== Solution Statistics ===\n";
    
    // Compute min/max/avg radiosity
    float minB = 1e10f, maxB = 0.0f, avgB = 0.0f;
    for (uint32_t i = 0; i < N; ++i) {
        float B_mag = patches.B_r[i] + patches.B_g[i] + patches.B_b[i];
        minB = std::min(minB, B_mag);
        maxB = std::max(maxB, B_mag);
        avgB += B_mag;
    }
    avgB /= float(N);
    
    std::cout << "Radiosity range: [" << minB << ", " << maxB << "]\n";
    std::cout << "Average radiosity: " << avgB << "\n";
}

} // namespace Solver
