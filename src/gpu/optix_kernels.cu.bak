//
// OptiX visibility kernel - Phase 2 (CORRECTED - SoA Architecture)
// Computes triangle-to-triangle visibility using segment rays
//
// ARCHITECTURE NOTE:
//   - World A (Traversal): vertices/indices used ONLY for OptiX GAS building
//   - World B (Compute): PatchSoA arrays (cx,cy,cz,nx,ny,nz) used for CUDA kernels
//   - This kernel belongs to World B - operates on precomputed SoA data
//

#include <optix.h>
#include <cuda_runtime.h>

// Launch parameters (uploaded to constant memory)
// Uses SoA layout for coalesced memory access
struct LaunchParams {
    // World A: vertices/indices for triangle sampling (needed for Phase 2 spec)
    float3* vertices;
    uint3* indices;
    
    // World B: Patch SoA arrays (precomputed, one entry per triangle)
    float* cx;     // centroid x [numTriangles]
    float* cy;     // centroid y [numTriangles]
    float* cz;     // centroid z [numTriangles]
    float* nx;     // normal x [numTriangles]
    float* ny;     // normal y [numTriangles]
    float* nz;     // normal z [numTriangles]
    
    float* visibility;    // output [numPairs] - visibility fraction [0,1]
    float* geometricKernel; // output [numPairs] - averaged geometric kernel K
    uint32_t numTriangles;
    uint32_t samplesPerPair;
    uint32_t iOffset;     // batch offset for i index
    OptixTraversableHandle gasHandle;
};

extern "C" {
    __constant__ LaunchParams params;
}

// Hammersley low-discrepancy sequence
__device__ inline float radicalInverse(uint32_t bits) {
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10f;
}

__device__ inline float2 hammersley(uint32_t i, uint32_t n) {
    return make_float2(float(i) / float(n), radicalInverse(i));
}

// Simple hash for Cranley-Patterson rotation
__device__ inline float2 hash2(uint32_t seed) {
    uint32_t x = seed * 1664525u + 1013904223u;
    uint32_t y = x * 1664525u + 1013904223u;
    return make_float2(float(x) * 2.3283064365386963e-10f,
                       float(y) * 2.3283064365386963e-10f);
}

// Hammersley sequence for stratified sampling
__device__ inline float2 hammersley2D(uint32_t i, uint32_t N) {
    uint32_t bits = i;
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    float ri = float(bits) * 2.3283064365386963e-10f;
    return make_float2(float(i) / float(N), ri);
}

// Uniform triangle sampling (correct area-weighted distribution)
// Reference: Pharr, Jakob, Humphreys - "Physically Based Rendering" (4th ed.), Section 13.6.1
//            Shirley & Chiu - "A Low Distortion Map Between Disk and Square" (1997)
//
// This mapping ensures UNIFORM area distribution over the triangle surface.
// The sqrt(u.x) term is critical - without it, samples would cluster near v0.
//
// Given uniform random variables u.x, u.y ∈ [0,1], the barycentric coordinates are:
//   b0 = 1 - sqrt(u.x)
//   b1 = sqrt(u.x) * (1 - u.y)  
//   b2 = sqrt(u.x) * u.y
//
// This gives P = b0*v0 + b1*v1 + b2*v2 with uniform area density.
// The transformation maps the unit square [0,1]² bijectively to the triangle,
// preserving stratification properties (important for Hammersley/low-discrepancy sequences).
__device__ inline float3 sampleTriangleUniform(const float3& v0, const float3& v1, const float3& v2, float2 u) {
    float su0 = sqrtf(u.x);
    float b0 = 1.0f - su0;
    float b1 = su0 * (1.0f - u.y);
    float b2 = su0 * u.y;
    return make_float3(
        b0 * v0.x + b1 * v1.x + b2 * v2.x,
        b0 * v0.y + b1 * v1.y + b2 * v2.y,
        b0 * v0.z + b1 * v1.z + b2 * v2.z
    );
}

extern "C" __global__ void __raygen__visibility() {
    const uint3 idx = optixGetLaunchIndex();
    
    // Map 2D launch to triangle pair (i, j) with i < j
    // Apply batch offset to i
    uint32_t i = params.iOffset + idx.x;
    uint32_t j = idx.y;
    
    if (i >= j || i >= params.numTriangles || j >= params.numTriangles) return;
    
    // Load precomputed patch data (SoA - coalesced access)
    float3 centroid_i = make_float3(params.cx[i], params.cy[i], params.cz[i]);
    float3 normal_i = make_float3(params.nx[i], params.ny[i], params.nz[i]);
    
    float3 centroid_j = make_float3(params.cx[j], params.cy[j], params.cz[j]);
    float3 normal_j = make_float3(params.nx[j], params.ny[j], params.nz[j]);
    
    // Early hemisphere check using centroids - skip if patches face away from each other
    float3 dir_ij = make_float3(
        centroid_j.x - centroid_i.x,
        centroid_j.y - centroid_i.y,
        centroid_j.z - centroid_i.z
    );
    float distSq_ij = dir_ij.x * dir_ij.x + dir_ij.y * dir_ij.y + dir_ij.z * dir_ij.z;
    
    if (distSq_ij > 1e-12f) {
        float invDist_ij = rsqrtf(distSq_ij);
        dir_ij.x *= invDist_ij;
        dir_ij.y *= invDist_ij;
        dir_ij.z *= invDist_ij;
        
        // Check if direction is in positive hemisphere for both patches
        float dot_i = normal_i.x * dir_ij.x + normal_i.y * dir_ij.y + normal_i.z * dir_ij.z;
        float dot_j = -(normal_j.x * dir_ij.x + normal_j.y * dir_ij.y + normal_j.z * dir_ij.z);
        
        if (dot_i <= 0.0f || dot_j <= 0.0f) {
            // Patches face away from each other - no visibility possible
            size_t pairIdx = (size_t(i) * (2 * params.numTriangles - i - 1)) / 2 + (j - i - 1);
            params.visibility[pairIdx] = 0.0f;
            return;
        }
    }
    
    // Load triangle vertices (for sampling - random access but necessary per Phase 2 spec)
    uint3 tri_i = params.indices[i];
    float3 v0_i = params.vertices[tri_i.x];
    float3 v1_i = params.vertices[tri_i.y];
    float3 v2_i = params.vertices[tri_i.z];
    
    uint3 tri_j = params.indices[j];
    float3 v0_j = params.vertices[tri_j.x];
    float3 v1_j = params.vertices[tri_j.y];
    float3 v2_j = params.vertices[tri_j.z];
    
    // Sample multiple point pairs per triangle pair (as per Phase 2 spec)
    uint32_t visibleCount = 0;
    uint32_t validSamples = 0;
    float kernelAccumulator = 0.0f;  // Accumulate geometric kernel values
    
    for (uint32_t k = 0; k < params.samplesPerPair; ++k) {
        // Generate stratified samples using Hammersley sequence
        float2 u_i = hammersley2D(k, params.samplesPerPair);
        float2 u_j = hammersley2D(k, params.samplesPerPair);

        // Apply Cranley-Patterson rotation (deterministic per pair)
        uint32_t seed = i * 65521u + j * 257u;
        float offset = float(seed & 0xFFFFu) / 65536.0f;
        u_i.x = fmodf(u_i.x + offset, 1.0f);
        u_j.y = fmodf(u_j.y + offset, 1.0f);

        // Sample points on triangles (uniform area-weighted)
        float3 p_i = sampleTriangleUniform(v0_i, v1_i, v2_i, u_i);
        float3 p_j = sampleTriangleUniform(v0_j, v1_j, v2_j, u_j);

        float3 diff = make_float3(p_j.x - p_i.x, p_j.y - p_i.y, p_j.z - p_i.z);
        float distSq = diff.x * diff.x + diff.y * diff.y + diff.z * diff.z;
        if (distSq < 1e-12f) {
            // Degenerate sample – skip but keep iterating to gather others
            continue;
        }

        float dist = sqrtf(distSq);
        float invDist = 1.0f / dist;
        float3 dir = make_float3(diff.x * invDist, diff.y * invDist, diff.z * invDist);

        float dot_i = normal_i.x * dir.x + normal_i.y * dir.y + normal_i.z * dir.z;
        float dot_j = -(normal_j.x * dir.x + normal_j.y * dir.y + normal_j.z * dir.z);
        if (dot_i <= 0.0f || dot_j <= 0.0f) {
            continue;
        }

        validSamples++;
        
        // Compute geometric kernel for this sample: K = (cos_i * cos_j) / (π * r²)
        float geometricKernel_k = (dot_i * dot_j) / (3.14159265f * distSq);
        kernelAccumulator += geometricKernel_k;

        float baseEps = 1e-4f;
        float eps = fmaxf(baseEps, baseEps * dist);
        float normalOffset = eps;
        float3 origin = make_float3(
            p_i.x + normal_i.x * normalOffset,
            p_i.y + normal_i.y * normalOffset,
            p_i.z + normal_i.z * normalOffset
        );

        float tmin = eps;
        float tmax = dist - eps;
        if (tmax <= tmin) {
            // Treat extremely short segments as visible to avoid NaNs
            visibleCount++;
            continue;
        }

        uint32_t visible = 1;
        optixTrace(
            params.gasHandle,
            origin,
            dir,
            tmin,
            tmax,
            0.0f,
            OptixVisibilityMask(255),
            OPTIX_RAY_FLAG_TERMINATE_ON_FIRST_HIT,
            0,
            1,
            0,
            visible
        );

        if (visible) {
            visibleCount++;
        }
    }
    
    // Calculate pair index for upper triangle matrix
    size_t pairIdx = (size_t(i) * (2 * params.numTriangles - i - 1)) / 2 + (j - i - 1);
    
    // Compute averaged values
    if (validSamples > 0) {
        // Visibility: fraction of visible samples
        float visibility = float(visibleCount) / float(validSamples);
        visibility = fminf(fmaxf(visibility, 0.0f), 1.0f);
        params.visibility[pairIdx] = visibility;
        
        // Geometric kernel: average over all valid samples
        float avgKernel = kernelAccumulator / float(validSamples);
        params.geometricKernel[pairIdx] = avgKernel;
    } else {
        // No valid samples - set both to zero
        params.visibility[pairIdx] = 0.0f;
        params.geometricKernel[pairIdx] = 0.0f;
    }
}

extern "C" __global__ void __miss__visibility() {
    // Ray missed - no occlusion, set visible
    optixSetPayload_0(1);
}

extern "C" __global__ void __closesthit__visibility() {
    // Ray hit something - occluded, set not visible
    optixSetPayload_0(0);
}
