#pragma once

#include "math/Vector3.h"
#include "math/MathUtils.h"
#include "core/Patch.h"
#include "visibility/VisibilityTester.h"
#include <cmath>
#include <algorithm>
#include <array>
#include <fstream>
#include <string>
#include <iostream>
#include <chrono>

namespace radiosity {

using math::Vector3;
using math::PI;
using core::Patch;
using visibility::VisibilityTester;

/**
 * Monte Carlo Form Factor Calculator (Deterministic Barycentric Sampling)
 * 
 * Computes form factors using deterministic surface sampling:
 * F_ij = (A_j/A_i) * (1/N) * Σ[(cos θi * cos θj * V(x,y)) / (π * r²)]
 * 
 * Uses fixed barycentric coordinates for all triangles:
 * - Sample i on triangle A always pairs with sample i on triangle B
 * - No random number generation (faster, reproducible)
 * - Perfect for uniformly tessellated geometry (Cornell Box)
 * - Stratified pattern ensures good coverage
 */
class MonteCarloFormFactor {
public:
    /**
     * Fixed UV sample points in [0,1]² space
     * 16 samples in a stratified 4x4 grid pattern
     * These work for ANY quad regardless of size
     */
    static constexpr int NUM_SAMPLES = 16;
    
    // DEBUG: Global flag to disable distance attenuation for testing
    static bool DEBUG_NO_DISTANCE_ATTENUATION;
    
    // Effective distance parameter (r² softening)
    // Compensates for missing area integration in point-to-point sampling
    // r²_eff = r² + α * A_receiver
    // Recommended: α = 0.5 (standard), range: 0.25 (conservative) to 1.0 (strong)
    static constexpr float EFFECTIVE_DISTANCE_ALPHA = 0.5f;
    
    // DEBUG: Enable loading/saving form factor matrix from/to cache file
    static bool DEBUG_ENABLE_CACHE;
    static std::string DEBUG_CACHE_FILENAME;
    
    static const std::array<Vector3, NUM_SAMPLES>& getUVSamples() {
        static const std::array<Vector3, NUM_SAMPLES> samples = {{
            // 4x4 stratified grid in [0,1]² (using x,y for u,v; z unused)
            // Row 0 (v ≈ 0.125)
            Vector3(0.125f, 0.125f, 0.0f),
            Vector3(0.375f, 0.125f, 0.0f),
            Vector3(0.625f, 0.125f, 0.0f),
            Vector3(0.875f, 0.125f, 0.0f),
            
            // Row 1 (v ≈ 0.375)
            Vector3(0.125f, 0.375f, 0.0f),
            Vector3(0.375f, 0.375f, 0.0f),
            Vector3(0.625f, 0.375f, 0.0f),
            Vector3(0.875f, 0.375f, 0.0f),
            
            // Row 2 (v ≈ 0.625)
            Vector3(0.125f, 0.625f, 0.0f),
            Vector3(0.375f, 0.625f, 0.0f),
            Vector3(0.625f, 0.625f, 0.0f),
            Vector3(0.875f, 0.625f, 0.0f),
            
            // Row 3 (v ≈ 0.875)
            Vector3(0.125f, 0.875f, 0.0f),
            Vector3(0.375f, 0.875f, 0.0f),
            Vector3(0.625f, 0.875f, 0.0f),
            Vector3(0.875f, 0.875f, 0.0f)
        }};
        return samples;
    }
    
    /**
     * Convert UV coordinates [0,1]² to world space point on a quad
     * Given quad vertices v0, v1, v2, v3 and UV coords (u, v):
     * worldPoint = bilinear interpolation
     */
    static Vector3 uvToWorld(
        const Vector3& v0,
        const Vector3& v1, 
        const Vector3& v2,
        const Vector3& v3,
        float u, float v)
    {
        // Bilinear interpolation:
        // (1-u)(1-v)v0 + u(1-v)v1 + uv*v2 + (1-u)v*v3
        float u0 = (1.0f - u) * (1.0f - v);
        float u1 = u * (1.0f - v);
        float u2 = u * v;
        float u3 = (1.0f - u) * v;
        
        return v0 * u0 + v1 * u1 + v2 * u2 + v3 * u3;
    }
    
    /**
     * Get the vertices of a patch (assumes square patch)
     * This constructs a quad from the patch center, normal, and area
     */
    static void getPatchVertices(
        const Patch& patch,
        Vector3& v0, Vector3& v1, Vector3& v2, Vector3& v3)
    {
        // Build tangent frame
        Vector3 up = std::abs(patch.normal.y) < 0.9f ? Vector3(0, 1, 0) : Vector3(1, 0, 0);
        Vector3 right = patch.normal.cross(up).normalized();
        Vector3 tangent = right.cross(patch.normal).normalized();
        
        // Assume square patch
        float size = std::sqrt(patch.area);
        float halfSize = size * 0.5f;
        
        // Four corners of the quad
        v0 = patch.center + right * (-halfSize) + tangent * (-halfSize);
        v1 = patch.center + right * (+halfSize) + tangent * (-halfSize);
        v2 = patch.center + right * (+halfSize) + tangent * (+halfSize);
        v3 = patch.center + right * (-halfSize) + tangent * (+halfSize);
    }
    
    /**
     * Calculate form factor using deterministic Monte Carlo surface integration
     * 
     * @param patchI Source patch
     * @param patchJ Target patch
     * @param visTester Visibility tester (OptiX ray tracing)
     * @param noDistanceAttenuation Debug flag to disable 1/r² falloff
     * @return Form factor F_ij (fraction of energy from i that reaches j)
     */
    static float calculate(
        const Patch& patchI,
        const Patch& patchJ,
        VisibilityTester* visTester = nullptr,
        bool noDistanceAttenuation = false)
    {
        // Don't compute self-interaction
        if (&patchI == &patchJ) {
            return 0.0f;
        }
        
        // Quick rejection: patches facing away
        Vector3 centerDir = (patchJ.center - patchI.center).normalized();
        float centerCosI = patchI.normal.dot(centerDir);
        float centerCosJ = patchJ.normal.dot(-centerDir);
        
        if (centerCosI <= 0.0f || centerCosJ <= 0.0f) {
            return 0.0f;
        }
        
        // Get patch vertices (assumes square patches)
        Vector3 v0_i, v1_i, v2_i, v3_i;
        Vector3 v0_j, v1_j, v2_j, v3_j;
        getPatchVertices(patchI, v0_i, v1_i, v2_i, v3_i);
        getPatchVertices(patchJ, v0_j, v1_j, v2_j, v3_j);
        
        // Get fixed UV samples
        auto samples = getUVSamples();
        
        // Accumulate contributions from all sample pairs
        float sumContribution = 0.0f;
        int validSamples = 0;
        
        // OPTIMIZATION: 1:1 point pairing between patches
        // Instead of testing all NxN combinations (256 rays), we use the SAME UV coordinates
        // for both patches, giving us only N rays (16 rays). This covers both surface areas
        // efficiently since we're using stratified sampling.
        // 
        // For each sample point: sample_i on patch_I ↔ sample_i on patch_J
        for (int s = 0; s < NUM_SAMPLES; ++s) {
            const Vector3& uv = samples[s];
            
            // Map UV coords to world space on quads
            Vector3 pointI = uvToWorld(v0_i, v1_i, v2_i, v3_i, uv.x, uv.y);
            Vector3 pointJ = uvToWorld(v0_j, v1_j, v2_j, v3_j, uv.x, uv.y);
            
            // Compute vector from i to j
            Vector3 r_ij = pointJ - pointI;
            float distSquared = r_ij.lengthSquared();
            
            if (distSquared < 1e-6f) {
                continue; // Skip degenerate samples
            }
            
            float dist = std::sqrt(distSquared);
            Vector3 dir = r_ij / dist;
            
            // Compute angles
            float cosI = patchI.normal.dot(dir);
            float cosJ = patchJ.normal.dot(-dir);
            
            // Skip if patches face away at this sample
            if (cosI <= 0.0f || cosJ <= 0.0f) {
                continue;
            }
            
            // Use pre-computed visibility fraction
            float visibility = visibilityFraction;
            
            // Effective distance (r² softening):
            // Compensates for missing area integration in discretized sampling
            // r²_eff = r² + α * A_receiver
            // This prevents over-attenuation at close range and accounts for patch extent
            float effectiveDistSquared = distSquared + EFFECTIVE_DISTANCE_ALPHA * patchJ.area;
            
            // Compute contribution: (cos θi * cos θj * V) / (π * r²_eff)
            // Debug mode: skip distance attenuation to see indirect lighting
            float contribution;
            if (noDistanceAttenuation || DEBUG_NO_DISTANCE_ATTENUATION) {
                contribution = (cosI * cosJ * visibility) / PI;  // No distance falloff
            } else {
                contribution = (cosI * cosJ * visibility) / (PI * effectiveDistSquared);
            }
            sumContribution += contribution;
            validSamples++;
        }
        
        if (validSamples == 0) {
            return 0.0f;
        }
        
        // Form factor Monte Carlo estimator with 1:1 point pairing:
        // With N samples uniformly distributed on BOTH patches using same UV coords:
        // F_ij ≈ (A_j / N) * Σ[kernel_k]
        // 
        // Note: This is correct for 1:1 pairing! Each sample pair covers both surfaces.
        // The sender area (A_i) normalization is implicit in the sampling density.
        float avgContribution = sumContribution / validSamples;
        float formFactor = patchJ.area * avgContribution;
        
        return formFactor;
    }
    
    /**
     * Save visibility matrix to binary cache file (values are 0.0 to 1.0)
     */
    static bool saveVisibilityToCache(const std::vector<std::vector<float>>& matrix, const std::string& filename) {
        std::ofstream file(filename, std::ios::binary);
        if (!file.is_open()) {
            std::cerr << "ERROR: Could not open cache file for writing: " << filename << std::endl;
            return false;
        }
        
        // Write dimensions
        size_t n = matrix.size();
        file.write(reinterpret_cast<const char*>(&n), sizeof(n));
        
        // Write matrix data row by row
        for (size_t i = 0; i < n; i++) {
            file.write(reinterpret_cast<const char*>(matrix[i].data()), n * sizeof(float));
        }
        
        file.close();
        std::cout << "✓ Visibility matrix cached to: " << filename << std::endl;
        std::cout << "  Size: " << n << "x" << n << " = " << (n * n) << " entries" << std::endl;
        std::cout << "  File size: " << (n * n * sizeof(float) / 1024.0f) << " KB" << std::endl;
        std::cout << "  Values: 0.0 (occluded) to 1.0 (visible) - ray hit fractions" << std::endl;
        return true;
    }
    
    /**
     * Load visibility matrix from binary cache file
     */
    static bool loadVisibilityFromCache(std::vector<std::vector<float>>& matrix, const std::string& filename, size_t expectedSize) {
        std::ifstream file(filename, std::ios::binary);
        if (!file.is_open()) {
            return false;  // File doesn't exist - not an error
        }
        
        // Read dimensions
        size_t n;
        file.read(reinterpret_cast<char*>(&n), sizeof(n));
        
        if (n != expectedSize) {
            std::cerr << "WARNING: Cached matrix size (" << n << ") doesn't match scene (" << expectedSize << ")" << std::endl;
            std::cerr << "         Ignoring cache and recomputing..." << std::endl;
            file.close();
            return false;
        }
        
        // Read matrix data
        matrix.resize(n, std::vector<float>(n));
        for (size_t i = 0; i < n; i++) {
            file.read(reinterpret_cast<char*>(matrix[i].data()), n * sizeof(float));
        }
        
        file.close();
        std::cout << "✓ Visibility matrix loaded from cache: " << filename << std::endl;
        std::cout << "  Size: " << n << "x" << n << " = " << (n * n) << " entries" << std::endl;
        std::cout << "  Values: 0.0 (occluded) to 1.0 (visible)" << std::endl;
        std::cout << "  Skipped expensive ray tracing!" << std::endl;
        return true;
    }
    
    /**
     * Calculate full form factor matrix for all patch pairs
     * Used by RadiosityRenderer for pre-computing form factors
     */
    static std::vector<std::vector<float>> calculateMatrix(
        const std::vector<core::Patch>& patches,
        visibility::VisibilityTester* visTester = nullptr,
        bool verbose = false,
        bool noDistanceAttenuation = false)
    {
        size_t n = patches.size();
        std::vector<std::vector<float>> visibilityMatrix(n, std::vector<float>(n, 0.0f));
        
        // Step 1: Compute or load visibility matrix (0.0 to 1.0)
        bool visibilityLoaded = false;
        if (DEBUG_ENABLE_CACHE && !DEBUG_CACHE_FILENAME.empty()) {
            if (loadVisibilityFromCache(visibilityMatrix, DEBUG_CACHE_FILENAME, n)) {
                visibilityLoaded = true;
                if (verbose) {
                    std::cout << "\n⚡ Using cached visibility - ray tracing skipped!\n" << std::endl;
                }
            } else if (verbose) {
                std::cout << "Cache miss - will compute visibility and save to: " << DEBUG_CACHE_FILENAME << "\n" << std::endl;
            }
        }
        
        // Compute visibility if not loaded from cache
        if (!visibilityLoaded) {
            if (verbose) {
                std::cout << "=== COMPUTING VISIBILITY (Ray Tracing) ===" << std::endl;
                std::cout << "Method: 16 rays per patch pair (1:1 UV sampling)" << std::endl;
                std::cout << "Patches: " << n << std::endl;
                std::cout << "Total rays: " << (n * (n - 1) * NUM_SAMPLES) << std::endl;
            }
            
            auto visStartTime = std::chrono::high_resolution_clock::now();
            
            for (size_t i = 0; i < n; i++) {
                for (size_t j = 0; j < n; j++) {
                    if (i == j) {
                        visibilityMatrix[i][j] = 0.0f;
                    } else {
                        visibilityMatrix[i][j] = computeVisibility(patches[i], patches[j], visTester);
                    }
                }
                
                if (verbose && (i % 50 == 0 || i == n - 1)) {
                    std::cout << "Visibility: " << (i + 1) << "/" << n << " patches processed" << std::endl;
                }
            }
            
            if (verbose) {
                auto visEndTime = std::chrono::high_resolution_clock::now();
                auto visElapsed = std::chrono::duration_cast<std::chrono::seconds>(visEndTime - visStartTime).count();
                std::cout << "✓ Visibility computation complete (" << visElapsed << "s)\n" << std::endl;
            }
            
            // Save visibility to cache
            if (DEBUG_ENABLE_CACHE && !DEBUG_CACHE_FILENAME.empty()) {
                saveVisibilityToCache(visibilityMatrix, DEBUG_CACHE_FILENAME);
            }
        }
        
        // Step 2: Compute form factors using visibility matrix
        std::vector<std::vector<float>> matrix(n, std::vector<float>(n, 0.0f));
        
        if (verbose) {
            std::cout << "\n=== COMPUTING FORM FACTORS (Geometric Terms) ===" << std::endl;
            std::cout << "Method: Using cached visibility + fresh geometric computation" << std::endl;
            std::cout << "Effective distance: r²_eff = r² + " << EFFECTIVE_DISTANCE_ALPHA << " * A_receiver" << std::endl;
            if (noDistanceAttenuation || DEBUG_NO_DISTANCE_ATTENUATION) {
                std::cout << "⚠ DEBUG MODE: Distance attenuation DISABLED" << std::endl;
            }
        }
        
        auto startTime = std::chrono::high_resolution_clock::now();
        
        for (size_t i = 0; i < n; i++) {
            for (size_t j = 0; j < n; j++) {
                if (i == j) {
                    matrix[i][j] = 0.0f;
                } else {
                    // Use pre-computed visibility from matrix
                    matrix[i][j] = calculate(patches[i], patches[j], visibilityMatrix[i][j], noDistanceAttenuation);
                }
            }
            
            if (verbose && (i % 5 == 0 || i == n - 1)) {
                auto currentTime = std::chrono::high_resolution_clock::now();
                auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(currentTime - startTime).count();
                
                // Calculate timing stats
                size_t patchesProcessed = i + 1;
                size_t patchesRemaining = n - patchesProcessed;
                
                // Average time per patch
                double avgTimePerPatch = (patchesProcessed > 0) ? (elapsed / (double)patchesProcessed) : 0.0;
                
                // Estimated remaining time
                double estimatedRemainingMs = avgTimePerPatch * patchesRemaining;
                
                // Format elapsed time
                int elapsedSec = elapsed / 1000;
                int elapsedMin = elapsedSec / 60;
                int elapsedHr = elapsedMin / 60;
                elapsedSec %= 60;
                elapsedMin %= 60;
                
                // Format remaining time
                int remainingSec = (int)(estimatedRemainingMs / 1000);
                int remainingMin = remainingSec / 60;
                int remainingHr = remainingMin / 60;
                remainingSec %= 60;
                remainingMin %= 60;
                
                // Batch time (time since last report)
                size_t batchSize = patchesProcessed - lastReportedPatch;
                double batchTimeMs = (batchSize > 0 && lastReportedPatch > 0) ? avgTimePerPatch * batchSize : avgTimePerPatch * patchesProcessed;
                
                std::cout << "Progress: " << patchesProcessed << "/" << n << " patches processed ";
                
                // Show batch timing
                if (batchSize > 0) {
                    std::cout << "[batch: " << (int)(batchTimeMs / 1000) << "s, ";
                } else {
                    std::cout << "[elapsed: ";
                }
                
                // Show ETA
                if (remainingHr > 0) {
                    std::cout << "ETA: " << remainingHr << "h " << remainingMin << "m]";
                } else if (remainingMin > 0) {
                    std::cout << "ETA: " << remainingMin << "m " << remainingSec << "s]";
                } else {
                    std::cout << "ETA: " << remainingSec << "s]";
                }
                
                std::cout << std::endl;
                lastReportedPatch = patchesProcessed;
            }
        }
        
        if (verbose) {
            auto endTime = std::chrono::high_resolution_clock::now();
            auto totalElapsed = std::chrono::duration_cast<std::chrono::seconds>(endTime - startTime).count();
            int totalMin = totalElapsed / 60;
            int totalHr = totalMin / 60;
            int totalSec = totalElapsed % 60;
            totalMin %= 60;
            
            std::cout << "\n✓ Form factor computation complete!" << std::endl;
            std::cout << "  Total time: ";
            if (totalHr > 0) {
                std::cout << totalHr << "h " << totalMin << "m " << totalSec << "s";
            } else if (totalMin > 0) {
                std::cout << totalMin << "m " << totalSec << "s";
            } else {
                std::cout << totalSec << "s";
            }
            std::cout << std::endl;
            
            std::cout << "\n=== FORM FACTOR STATISTICS ===" << std::endl;
            
            // Validate reciprocity
            float maxReciprocityError = 0.0f;
            for (size_t i = 0; i < n; i++) {
                for (size_t j = i + 1; j < n; j++) {
                    float Fij = matrix[i][j];
                    float Fji = matrix[j][i];
                    float Ai = patches[i].area;
                    float Aj = patches[j].area;
                    
                    float leftSide = Ai * Fij;
                    float rightSide = Aj * Fji;
                    
                    if (leftSide > 1e-9f || rightSide > 1e-9f) {
                        float error = std::abs(leftSide - rightSide) / std::max(leftSide, rightSide);
                        maxReciprocityError = std::max(maxReciprocityError, error);
                    }
                }
            }
            
            std::cout << "Maximum reciprocity error: " << (maxReciprocityError * 100.0f) << "%" << std::endl;
            
            // Validate energy conservation (sum of form factors)
            std::cout << "\nForm factor row sums (should be <= 1.0 for enclosed scenes):" << std::endl;
            float minSum = 1.0f, maxSum = 0.0f;
            int violationCount = 0;
            for (size_t i = 0; i < n; i++) {
                float sum = 0.0f;
                for (size_t j = 0; j < n; j++) {
                    sum += matrix[i][j];
                }
                minSum = std::min(minSum, sum);
                maxSum = std::max(maxSum, sum);
                if (sum > 1.01f) {
                    violationCount++;
                    if (violationCount <= 3) {
                        std::cout << "  ⚠ Patch " << i << ": " << sum << " (EXCEEDS 1.0!)" << std::endl;
                    }
                }
                if (i < 5) {
                    std::cout << "  Patch " << i << ": " << sum << std::endl;
                }
            }
            if (n > 5) {
                std::cout << "  ..." << std::endl;
            }
            std::cout << "  Range: [" << minSum << ", " << maxSum << "]" << std::endl;
            if (violationCount > 0) {
                std::cout << "  ⚠ WARNING: " << violationCount << " patches exceed 1.0 (energy conservation violated!)" << std::endl;
            }
            
            std::cout << std::endl;
        }
        
        return matrix;
    }
};

// Define static members
inline bool MonteCarloFormFactor::DEBUG_NO_DISTANCE_ATTENUATION = false;
inline bool MonteCarloFormFactor::DEBUG_ENABLE_CACHE = false;
inline std::string MonteCarloFormFactor::DEBUG_CACHE_FILENAME = "form_factors.cache";

} // namespace radiosity
